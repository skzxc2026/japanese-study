<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ—¥è¯­è¯æ€§ä¼ é€å¸¦</title>
    <style>
        :root {
            --noun-color: #ff9ff3; /* åè¯-å…”-ç²‰ */
            --part-color: #54a0ff; /* åŠ©è¯-çŒ«-è“ */
            --adv-color: #feca57;  /* å‰¯è¯-ç‹—-é»„ */
            --verb-color: #1dd1a1; /* åŠ¨è¯-ç†Š-ç»¿ */
            --belt-speed: 2s;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            font-family: "Microsoft YaHei", sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* é¡¶éƒ¨çŠ¶æ€æ  */
        .header {
            height: 50px;
            background: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            z-index: 10;
        }
        .stat-box { font-weight: bold; color: #555; display: flex; align-items: center; gap: 5px; }
        .heart { color: #ff4757; }

        /* æ¸¸æˆä¸»åŒºåŸŸ */
        #game-stage {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden;
        }

        /* èŒå® åˆ†ç±»åŒº (é¡¶éƒ¨) */
        .animal-zones {
            display: flex;
            justify-content: space-around;
            padding: 10px 5px;
            background: rgba(255,255,255,0.5);
        }

        .zone {
            width: 22%;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.2s;
        }
        
        .avatar {
            font-size: 2.5rem;
            filter: drop-shadow(0 3px 0 rgba(0,0,0,0.1));
            z-index: 2;
        }
        
        .box {
            width: 100%;
            height: 60px;
            border-radius: 10px;
            margin-top: -10px;
            padding-top: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
            font-size: 1rem;
            box-shadow: inset 0 -3px 0 rgba(0,0,0,0.2);
            border: 2px solid transparent;
        }

        /* åˆ†ç±»æ ·å¼ */
        .zone[data-type="noun"] .box { background: var(--noun-color); }
        .zone[data-type="particle"] .box { background: var(--part-color); }
        .zone[data-type="adverb"] .box { background: var(--adv-color); }
        .zone[data-type="verb"] .box { background: var(--verb-color); }

        .zone.hover { transform: scale(1.1); }
        .zone.hover .box { border-color: white; box-shadow: 0 0 15px rgba(0,0,0,0.2); }

        /* ä¼ é€å¸¦åŒºåŸŸ (åº•éƒ¨) */
        .conveyor-belt {
            height: 140px;
            background: #576574;
            position: relative;
            display: flex;
            align-items: center;
            border-top: 5px solid #222f3e;
            border-bottom: 5px solid #222f3e;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        /* ä¼ é€å¸¦çº¹ç†åŠ¨ç”» */
        .belt-track {
            position: absolute;
            top: 0; left: 0; width: 200%; height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent 0px,
                transparent 40px,
                rgba(0,0,0,0.1) 40px,
                rgba(0,0,0,0.1) 44px
            );
            animation: scrollBelt 2s linear infinite;
        }

        /* å±é™©åŒºåŸŸè­¦ç¤ºçº¿ */
        .danger-zone {
            position: absolute;
            left: 0; top: 0; height: 100%; width: 80px;
            background: linear-gradient(to right, rgba(255,0,0,0.3), transparent);
            z-index: 1;
            pointer-events: none;
        }

        @keyframes scrollBelt {
            from { transform: translateX(0); }
            to { transform: translateX(-50%); } /* å‘å·¦æ»šåŠ¨ */
        }

        /* å•è¯å¡ç‰‡ */
        .word-card {
            position: absolute;
            background: white;
            padding: 8px 15px;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: bold;
            color: #333;
            font-size: 1.1rem;
            cursor: grab;
            white-space: nowrap;
            z-index: 10;
            top: 40px; /* åœ¨ä¼ é€å¸¦ä¸­é—´ */
            user-select: none;
        }

        .word-card:active { cursor: grabbing; }

        .word-card.dragging {
            box-shadow: 0 15px 30px rgba(0,0,0,0.3);
            transform: scale(1.1) rotate(-3deg);
            z-index: 100;
            opacity: 0.9;
        }

        /* æ¿’æ­»é—ªçƒåŠ¨ç”» */
        .word-card.danger {
            animation: flashRed 0.5s infinite;
            color: red;
            border: 2px solid red;
        }

        @keyframes flashRed {
            0%, 100% { background: white; }
            50% { background: #ffcccc; }
        }

        /* é®ç½©å±‚ */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }
        .btn {
            background: #ff6b6b; color: white; border: none; padding: 15px 50px;
            font-size: 1.5rem; border-radius: 50px; cursor: pointer;
            margin-top: 30px; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* æµ®åŠ¨å¾—åˆ† */
        .float-score {
            position: absolute;
            font-weight: bold;
            font-size: 1.5rem;
            pointer-events: none;
            animation: floatUp 0.8s forwards;
            z-index: 999;
        }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-50px); } }

    </style>
</head>
<body>

    <div class="header">
        <div class="stat-box">
            <i class="fas fa-star" style="color:#f1c40f"></i> <span id="score">0</span>
        </div>
        <div class="stat-box">
            <span style="font-size:0.8rem; color:#999">SPEED: <span id="speed-display">1.0</span>x</span>
        </div>
        <div class="stat-box">
            <i class="fas fa-heart heart"></i> <span id="lives">5</span>
        </div>
    </div>

    <div id="game-stage">
        <!-- èŒå® åˆ†ç±»åŒº -->
        <div class="animal-zones">
            <div class="zone" data-type="noun">
                <div class="avatar">ğŸ°</div>
                <div class="box">åè¯</div>
            </div>
            <div class="zone" data-type="particle">
                <div class="avatar">ğŸ±</div>
                <div class="box">åŠ©è¯</div>
            </div>
            <div class="zone" data-type="adverb">
                <div class="avatar">ğŸ¶</div>
                <div class="box">å‰¯è¯</div>
            </div>
            <div class="zone" data-type="verb">
                <div class="avatar">ğŸ»</div>
                <div class="box">åŠ¨è¯</div>
            </div>
        </div>

        <!-- ä¼ é€å¸¦ -->
        <div class="conveyor-belt" id="belt">
            <div class="belt-track"></div>
            <div class="danger-zone"></div>
            <!-- å•è¯å¡ç‰‡ä¼šç”Ÿæˆåœ¨è¿™é‡Œ -->
        </div>
    </div>

    <!-- é®ç½© -->
    <div id="overlay">
        <h1 style="font-size: 2.5rem; margin-bottom: 10px;">ğŸ“¦ è¯æ€§ä¼ é€å¸¦</h1>
        <p style="color:#ccc; font-size: 1.1rem; max-width: 80%;">
            å•è¯æ­£åœ¨è¢«è¿å¾€ç²‰ç¢æœºï¼<br>
            å¿«æŠŠå®ƒä»¬æ‹–ç»™æ­£ç¡®çš„å°åŠ¨ç‰©ï¼
        </p>
        <div style="display:flex; gap:15px; margin-top:20px; font-size:0.9rem; opacity:0.8">
            <span>ğŸ° åè¯</span>
            <span>ğŸ± åŠ©è¯</span>
            <span>ğŸ¶ å‰¯è¯</span>
            <span>ğŸ» åŠ¨è¯</span>
        </div>
        <button class="btn" onclick="startGame()">å¼€å§‹æŒ‘æˆ˜</button>
    </div>

<script>
    // === 1. è¯åº“ (AI ç”Ÿæˆ) ===
    const WORD_DB = [
        // åè¯ (Noun)
        { w: "çŒ«", t: "noun" }, { w: "å­¦æ ¡", t: "noun" }, { w: "æ˜æ—¥", t: "noun" },
        { w: "æ˜ ç”»", t: "noun" }, { w: "éŸ³æ¥½", t: "noun" }, { w: "æ°´", t: "noun" },
        { w: "éŠ€è¡Œ", t: "noun" }, { w: "éƒ¨å±‹", t: "noun" }, { w: "å…ˆç”Ÿ", t: "noun" },
        { w: "æ—¥æœ¬", t: "noun" }, { w: "æ‰‹ç´™", t: "noun" }, { w: "å¤©æ°—", t: "noun" },
        { w: "é‡èœ", t: "noun" }, { w: "æºå¸¯", t: "noun" }, { w: "é›»è»Š", t: "noun" },
        
        // åŠ©è¯ (Particle)
        { w: "ã¯", t: "particle" }, { w: "ãŒ", t: "particle" }, { w: "ã‚’", t: "particle" },
        { w: "ã«", t: "particle" }, { w: "ã§", t: "particle" }, { w: "ã¸", t: "particle" },
        { w: "ã¨", t: "particle" }, { w: "ã‹ã‚‰", t: "particle" }, { w: "ã¾ã§", t: "particle" },
        { w: "ã‚ˆã‚Š", t: "particle" }, { w: "ã®", t: "particle" }, { w: "ã‚„", t: "particle" },
        
        // å‰¯è¯ (Adverb)
        { w: "ã¨ã¦ã‚‚", t: "adverb" }, { w: "ãŸã¶ã‚“", t: "adverb" }, { w: "ã™ã", t: "adverb" },
        { w: "ã‚†ã£ãã‚Š", t: "adverb" }, { w: "å…¨ç„¶", t: "adverb" }, { w: "ã‚‚ã£ã¨", t: "adverb" },
        { w: "ã¡ã‚‡ã†ã©", t: "adverb" }, { w: "ãã£ã¨", t: "adverb" }, { w: "ã¾ã ", t: "adverb" },
        { w: "ã„ã¤ã‚‚", t: "adverb" }, { w: "æ™‚ã€…", t: "adverb" }, { w: "å°‘ã—", t: "adverb" },
        
        // åŠ¨è¯ (Verb)
        { w: "é£Ÿã¹ã‚‹", t: "verb" }, { w: "è¡Œã", t: "verb" }, { w: "è¦‹ã‚‹", t: "verb" },
        { w: "å¯ã‚‹", t: "verb" }, { w: "å‹‰å¼·ã™ã‚‹", t: "verb" }, { w: "å¸°ã‚‹", t: "verb" },
        { w: "é£²ã‚€", t: "verb" }, { w: "è©±ã™", t: "verb" }, { w: "æ³³ã", t: "verb" },
        { w: "è²·ã†", t: "verb" }, { w: "å¾…ã¤", t: "verb" }, { w: "éŠã¶", t: "verb" },
        { w: "æ¥ã‚‹", t: "verb" }, { w: "ã™ã‚‹", t: "verb" }, { w: "æ›¸ã", t: "verb" }
    ];

    // === 2. æ¸¸æˆçŠ¶æ€ ===
    let state = {
        isPlaying: false,
        score: 0,
        lives: 5,
        speed: 1.5, // åƒç´ /å¸§
        spawnRate: 120, // å¸§æ•°é—´éš”
        frameCount: 0,
        activeWords: [] // å­˜æ”¾å½“å‰å±å¹•ä¸Šçš„å•è¯å¯¹è±¡
    };

    let animationId;
    const beltEl = document.getElementById('belt');

    // === 3. éŸ³æ•ˆ ===
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'correct') {
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.linearRampToValueAtTime(1000, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(now); osc.stop(now + 0.2);
        } else if (type === 'wrong') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.3);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        }
    }

    // === 4. æ ¸å¿ƒå¾ªç¯ ===
    function startGame() {
        document.getElementById('overlay').style.display = 'none';
        
        // é‡ç½®çŠ¶æ€
        state.isPlaying = true;
        state.score = 0;
        state.lives = 5;
        state.speed = 1.0;
        state.spawnRate = 120;
        state.frameCount = 0;
        state.activeWords.forEach(w => w.el.remove());
        state.activeWords = [];

        updateUI();
        gameLoop();
    }

    function gameLoop() {
        if (!state.isPlaying) return;

        state.frameCount++;

        // 1. ç”Ÿæˆæ–°å•è¯
        if (state.frameCount % Math.floor(state.spawnRate) === 0) {
            spawnWord();
        }

        // 2. å¢åŠ éš¾åº¦ (æ¯600å¸§åŠ é€Ÿä¸€æ¬¡)
        if (state.frameCount % 600 === 0) {
            state.speed += 0.2;
            state.spawnRate = Math.max(40, state.spawnRate - 5); // æœ€å°é—´éš”40å¸§
            updateUI();
        }

        // 3. ç§»åŠ¨å•è¯
        moveWords();

        animationId = requestAnimationFrame(gameLoop);
    }

    function spawnWord() {
        const data = WORD_DB[Math.floor(Math.random() * WORD_DB.length)];
        const el = document.createElement('div');
        el.className = 'word-card';
        el.textContent = data.w;
        
        // åˆå§‹ä½ç½®ï¼šä¼ é€å¸¦æœ€å³ä¾§
        const startX = beltEl.offsetWidth;
        el.style.left = startX + 'px';
        
        beltEl.appendChild(el);

        const wordObj = {
            el: el,
            type: data.t,
            x: startX,
            isDragging: false,
            width: 0 // ç¨åè·å–
        };

        // ç»‘å®šæ‹–æ‹½
        initDraggable(wordObj);
        
        state.activeWords.push(wordObj);
    }

    function moveWords() {
        // å€’åºéå†ï¼Œæ–¹ä¾¿åˆ é™¤
        for (let i = state.activeWords.length - 1; i >= 0; i--) {
            const word = state.activeWords[i];
            
            // å¦‚æœæ­£åœ¨è¢«æ‹–æ‹½ï¼Œä¸éšä¼ é€å¸¦ç§»åŠ¨
            if (word.isDragging) continue;

            // ç§»åŠ¨é€»è¾‘
            word.x -= state.speed;
            word.el.style.left = word.x + 'px';

            // è·å–å®½åº¦ç”¨äºåˆ¤æ–­è¾¹ç•Œ
            if (word.width === 0) word.width = word.el.offsetWidth;

            // è­¦ç¤ºé€»è¾‘ (æ¥è¿‘å·¦ä¾§)
            if (word.x < 80) {
                word.el.classList.add('danger');
            }

            // è¶Šç•Œåˆ¤å®š (å®Œå…¨ç¦»å¼€å·¦ä¾§)
            if (word.x + word.width < 0) {
                handleMiss(word, i);
            }
        }
    }

    function handleMiss(word, index) {
        word.el.remove();
        state.activeWords.splice(index, 1);
        loseLife();
    }

    function loseLife() {
        state.lives--;
        playSound('wrong');
        updateUI();
        
        // å±å¹•é—ªçº¢
        document.body.style.background = '#ffcccc';
        setTimeout(() => document.body.style.background = '#f0f2f5', 100);

        if (state.lives <= 0) {
            gameOver();
        }
    }

    function updateUI() {
        document.getElementById('score').innerText = state.score;
        document.getElementById('lives').innerText = state.lives;
        document.getElementById('speed-display').innerText = state.speed.toFixed(1);
    }

    // === 5. æ‹–æ‹½é€»è¾‘ (å…³é”®) ===
    let dragOffset = { x: 0, y: 0 };
    let currentDragWord = null;

    function initDraggable(wordObj) {
        const startDrag = (e) => {
            if (!state.isPlaying) return;
            e.preventDefault(); // é˜²æ­¢æ»šåŠ¨

            currentDragWord = wordObj;
            wordObj.isDragging = true;
            wordObj.el.classList.add('dragging');

            // åˆ‡æ¢åæ ‡ç³»ï¼šä» belt å†…éƒ¨ç»å¯¹å®šä½ -> body ç»å¯¹å®šä½
            // è¿™æ ·æ‹–æ‹½æ—¶å¯ä»¥ç¦»å¼€ä¼ é€å¸¦åŒºåŸŸ
            const rect = wordObj.el.getBoundingClientRect();
            wordObj.el.style.position = 'fixed'; // å˜æˆ fixed
            wordObj.el.style.left = rect.left + 'px';
            wordObj.el.style.top = rect.top + 'px';
            document.body.appendChild(wordObj.el); // ç§»åˆ° body ä¸‹

            const point = e.touches ? e.touches[0] : e;
            dragOffset.x = point.clientX - rect.left;
            dragOffset.y = point.clientY - rect.top;

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag, { passive: false });
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
        };

        wordObj.el.addEventListener('mousedown', startDrag);
        wordObj.el.addEventListener('touchstart', startDrag, { passive: false });
    }

    function onDrag(e) {
        if (!currentDragWord) return;
        e.preventDefault();
        
        const point = e.touches ? e.touches[0] : e;
        const x = point.clientX - dragOffset.x;
        const y = point.clientY - dragOffset.y;

        currentDragWord.el.style.left = x + 'px';
        currentDragWord.el.style.top = y + 'px';

        checkHover(point.clientX, point.clientY);
    }

    function endDrag(e) {
        if (!currentDragWord) return;

        const rect = currentDragWord.el.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        const target = getTargetZone(centerX, centerY);

        if (target) {
            // å‘½ä¸­ç›’å­
            if (target.dataset.type === currentDragWord.type) {
                // æ­£ç¡®
                handleCorrect(currentDragWord, target);
            } else {
                // é”™è¯¯
                handleWrong(currentDragWord);
            }
        } else {
            // æ²¡æ”¾è¿›ç›’å­ -> æ”¾å›ä¼ é€å¸¦
            returnToBelt(currentDragWord);
        }

        // æ¸…ç†äº‹ä»¶
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('touchend', endDrag);
        
        document.querySelectorAll('.zone').forEach(z => z.classList.remove('hover'));
        currentDragWord = null;
    }

    function checkHover(x, y) {
        document.querySelectorAll('.zone').forEach(z => {
            const r = z.getBoundingClientRect();
            if (x > r.left && x < r.right && y > r.top && y < r.bottom) {
                z.classList.add('hover');
            } else {
                z.classList.remove('hover');
            }
        });
    }

    function getTargetZone(x, y) {
        let target = null;
        document.querySelectorAll('.zone').forEach(z => {
            const r = z.getBoundingClientRect();
            if (x > r.left && x < r.right && y > r.top && y < r.bottom) {
                target = z;
            }
        });
        return target;
    }

    // === 6. åˆ¤å®šé€»è¾‘ ===

    function handleCorrect(wordObj, zone) {
        playSound('correct');
        state.score += 10;
        updateUI();
        showFloatText(zone, "+10");

        // ç§»é™¤æ•°æ®
        const idx = state.activeWords.indexOf(wordObj);
        if (idx > -1) state.activeWords.splice(idx, 1);
        wordObj.el.remove();
    }

    function handleWrong(wordObj) {
        loseLife();
        showFloatText(wordObj.el, "âŒ");
        
        // ç§»é™¤æ•°æ®
        const idx = state.activeWords.indexOf(wordObj);
        if (idx > -1) state.activeWords.splice(idx, 1);
        wordObj.el.remove();
    }

    function returnToBelt(wordObj) {
        // æ¢å¤çŠ¶æ€
        wordObj.isDragging = false;
        wordObj.el.classList.remove('dragging');
        
        // æ”¾å› belt DOM ç»“æ„
        wordObj.el.style.position = 'absolute';
        wordObj.el.style.top = '40px'; // æ¢å¤é«˜åº¦
        wordObj.el.style.left = wordObj.x + 'px'; // æ¢å¤ X è½´ä½ç½®
        beltEl.appendChild(wordObj.el);
    }

    function showFloatText(targetEl, text) {
        const rect = targetEl.getBoundingClientRect();
        const floatEl = document.createElement('div');
        floatEl.className = 'float-score';
        floatEl.innerText = text;
        floatEl.style.left = (rect.left + rect.width/2 - 20) + 'px';
        floatEl.style.top = rect.top + 'px';
        floatEl.style.color = text === 'âŒ' ? 'red' : '#2ecc71';
        document.body.appendChild(floatEl);
        setTimeout(() => floatEl.remove(), 800);
    }

    function gameOver() {
        state.isPlaying = false;
        cancelAnimationFrame(animationId);
        
        const overlay = document.getElementById('overlay');
        overlay.innerHTML = `
            <h1 style="font-size:3rem">ğŸ’€ æ¸¸æˆç»“æŸ</h1>
            <p style="font-size:1.5rem">æœ€ç»ˆå¾—åˆ†: <span style="color:#f1c40f">${state.score}</span></p>
            <button class="btn" onclick="startGame()">å†è¯•ä¸€æ¬¡</button>
        `;
        overlay.style.display = 'flex';
    }

</script>
</body>
</html>
