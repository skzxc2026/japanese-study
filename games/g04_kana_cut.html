<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å‡ååˆ‡åˆ‡ä¹</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: "Microsoft YaHei", sans-serif; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* ç•Œé¢ UI */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ° Canvas */
            display: flex; flex-direction: column; justify-content: space-between;
        }
        
        .top-bar {
            padding: 20px; display: flex; justify-content: space-between;
            color: white; font-size: 1.5rem; font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        /* ä»»åŠ¡æç¤ºæ¡† */
        #task-box {
            position: absolute; top: 80px; width: 100%; text-align: center;
            pointer-events: none;
        }
        .task-label {
            display: inline-block; background: rgba(255, 193, 7, 0.9); color: #333;
            padding: 10px 30px; border-radius: 50px; font-size: 1.8rem; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 193, 7, 0.5);
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        /* å¼€å§‹/ç»“æŸèœå• */
        #menu-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 100; pointer-events: auto;
        }
        .btn {
            background: linear-gradient(45deg, #FF5252, #D32F2F);
            color: white; border: none; padding: 15px 50px;
            font-size: 1.5rem; border-radius: 50px; margin-top: 30px;
            cursor: pointer; box-shadow: 0 5px 15px rgba(211, 47, 47, 0.4);
            font-weight: bold;
        }

        @keyframes popIn { 0% { transform: scale(0); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="top-bar">
            <div id="score-display">å¾—åˆ†: 0</div>
            <div id="time-display">60s</div>
        </div>
        <div id="task-box">
            <div id="current-task" class="task-label">å‡†å¤‡å¼€å§‹...</div>
        </div>
    </div>

    <div id="menu-layer">
        <h1 style="font-size: 3rem; color: #FF5252; margin-bottom: 10px;">âš”ï¸ å‡åå¿è€…</h1>
        <p>åˆ‡ä¸­æŒ‡å®šå‡åå¾—åˆ†ï¼Œåˆ‡é”™æ‰£åˆ†ï¼</p>
        <p style="color:#aaa;">å°å¿ƒç‚¸å¼¹ğŸ’£ï¼ŒæŠ¢æ—¶é’Ÿâ°</p>
        <button class="btn" onclick="startGame()">å¼€å§‹æ‹”åˆ€</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // === æ•°æ®å®šä¹‰ ===
    const HIRAGANA = "ã‚ã„ã†ãˆãŠã‹ããã‘ã“ã•ã—ã™ã›ããŸã¡ã¤ã¦ã¨ãªã«ã¬ã­ã®ã¯ã²ãµã¸ã»ã¾ã¿ã‚€ã‚ã‚‚ã‚„ã‚†ã‚ˆã‚‰ã‚Šã‚‹ã‚Œã‚ã‚ã‚’ã‚“".split('');
    const KATAKANA = "ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ²ãƒ³".split('');
    
    const DAKUON_HIRA = "ãŒããã’ã”ã–ã˜ãšãœãã ã¢ã¥ã§ã©ã°ã³ã¶ã¹ã¼ã±ã´ã·ãºã½".split(''); // å«åŠæµŠéŸ³
    const DAKUON_KATA = "ã‚¬ã‚®ã‚°ã‚²ã‚´ã‚¶ã‚¸ã‚ºã‚¼ã‚¾ãƒ€ãƒ‚ãƒ…ãƒ‡ãƒ‰ãƒãƒ“ãƒ–ãƒ™ãƒœãƒ‘ãƒ”ãƒ—ãƒšãƒ".split('');
    
    const YOON_HIRA = ["ãã‚ƒ","ãã‚…","ãã‚‡","ã—ã‚ƒ","ã—ã‚…","ã—ã‚‡","ã¡ã‚ƒ","ã¡ã‚…","ã¡ã‚‡","ã«ã‚ƒ","ã«ã‚…","ã«ã‚‡","ã²ã‚ƒ","ã²ã‚…","ã²ã‚‡","ã¿ã‚ƒ","ã¿ã‚…","ã¿ã‚‡","ã‚Šã‚ƒ","ã‚Šã‚…","ã‚Šã‚‡","ãã‚ƒ","ãã‚…","ãã‚‡","ã˜ã‚ƒ","ã˜ã‚…","ã˜ã‚‡","ã¢ã‚ƒ","ã¢ã‚…","ã¢ã‚‡","ã³ã‚ƒ","ã³ã‚…","ã³ã‚‡","ã´ã‚ƒ","ã´ã‚…","ã´ã‚‡"];
    const YOON_KATA = ["ã‚­ãƒ£","ã‚­ãƒ¥","ã‚­ãƒ§","ã‚·ãƒ£","ã‚·ãƒ¥","ã‚·ãƒ§","ãƒãƒ£","ãƒãƒ¥","ãƒãƒ§","ãƒ‹ãƒ£","ãƒ‹ãƒ¥","ãƒ‹ãƒ§","ãƒ’ãƒ£","ãƒ’ãƒ¥","ãƒ’ãƒ§","ãƒŸãƒ£","ãƒŸãƒ¥","ãƒŸãƒ§","ãƒªãƒ£","ãƒªãƒ¥","ãƒªãƒ§","ã‚®ãƒ£","ã‚®ãƒ¥","ã‚®ãƒ§","ã‚¸ãƒ£","ã‚¸ãƒ¥","ã‚¸ãƒ§","ãƒ‚ãƒ£","ãƒ‚ãƒ¥","ãƒ‚ãƒ§","ãƒ“ãƒ£","ãƒ“ãƒ¥","ãƒ“ãƒ§","ãƒ”ãƒ£","ãƒ”ãƒ¥","ãƒ”ãƒ§"];

    // ä»»åŠ¡ç±»å‹
    const TASKS = [
        { id: 'hira', label: "åˆ‡å¹³å‡åï¼(ã‚)", check: (t) => HIRAGANA.includes(t) || DAKUON_HIRA.includes(t) || YOON_HIRA.includes(t) },
        { id: 'kata', label: "åˆ‡ç‰‡å‡åï¼(ã‚¢)", check: (t) => KATAKANA.includes(t) || DAKUON_KATA.includes(t) || YOON_KATA.includes(t) },
        { id: 'daku', label: "åˆ‡æµŠéŸ³/åŠæµŠéŸ³ï¼(ã‚›ã‚œ)", check: (t) => DAKUON_HIRA.includes(t) || DAKUON_KATA.includes(t) },
        { id: 'yoon', label: "åˆ‡æ‹—éŸ³ï¼(ya/yu/yo)", check: (t) => YOON_HIRA.includes(t) || YOON_KATA.includes(t) }
    ];

    // === æ¸¸æˆå¼•æ“ ===
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let width, height;

    let gameState = 'menu'; // menu, playing, gameover
    let score = 0;
    let timeLeft = 60;
    let currentTask = TASKS[0];
    let fruits = []; // é£å‡ºçš„ç‰©ä½“
    let particles = []; // ç²’å­ç‰¹æ•ˆ
    let trail = []; // é¼ æ ‡è½¨è¿¹
    let spawnTimer = 0;
    let taskTimer = 0;
    let gameLoopId;

    // é¼ æ ‡/è§¦æ‘¸ä½ç½®
    let inputPos = { x: 0, y: 0, isDown: false };

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // === è¾“å…¥å¤„ç† ===
    function handleInputMove(x, y) {
        inputPos.x = x; inputPos.y = y;
        if (inputPos.isDown) {
            trail.push({ x: x, y: y, life: 1.0 });
            if (trail.length > 10) trail.shift();
            checkSlice(x, y);
        }
    }
    
    canvas.addEventListener('mousedown', e => { inputPos.isDown = true; trail = []; });
    canvas.addEventListener('mousemove', e => handleInputMove(e.clientX, e.clientY));
    canvas.addEventListener('mouseup', () => { inputPos.isDown = false; trail = []; });

    canvas.addEventListener('touchstart', e => { e.preventDefault(); inputPos.isDown = true; trail = []; }, {passive: false});
    canvas.addEventListener('touchmove', e => { e.preventDefault(); handleInputMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
    canvas.addEventListener('touchend', () => { inputPos.isDown = false; trail = []; });

    // === æ¸¸æˆé€»è¾‘ ===
    function startGame() {
        document.getElementById('menu-layer').style.display = 'none';
        gameState = 'playing';
        score = 0;
        timeLeft = 60;
        fruits = [];
        particles = [];
        trail = [];
        
        changeTask();
        gameLoop();
        
        // å€’è®¡æ—¶
        const timerId = setInterval(() => {
            if (gameState !== 'playing') { clearInterval(timerId); return; }
            timeLeft--;
            document.getElementById('time-display').innerText = timeLeft + 's';
            if (timeLeft <= 0) gameOver();
        }, 1000);
    }

    function changeTask() {
        currentTask = TASKS[Math.floor(Math.random() * TASKS.length)];
        const el = document.getElementById('current-task');
        el.innerText = currentTask.label;
        // åŠ¨ç”»é‡ç½®
        el.style.animation = 'none';
        el.offsetHeight; /* trigger reflow */
        el.style.animation = 'popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
    }

    function spawnFruit() {
        // 5% ç‚¸å¼¹, 5% æ—¶é’Ÿ, 90% å‡å
        const rand = Math.random();
        let type, text, color;
        
        if (rand < 0.05) {
            type = 'bomb'; text = 'ğŸ’£'; color = '#333';
        } else if (rand < 0.1) {
            type = 'clock'; text = 'â°'; color = '#FFD700';
        } else {
            type = 'kana';
            // éšæœºä»æ‰€æœ‰æ± å­é‡Œé€‰ä¸€ä¸ª
            const pools = [HIRAGANA, KATAKANA, DAKUON_HIRA, DAKUON_KATA, YOON_HIRA, YOON_KATA];
            const pool = pools[Math.floor(Math.random() * pools.length)];
            text = pool[Math.floor(Math.random() * pool.length)];
            
            // é¢œè‰²åŒºåˆ†
            if (HIRAGANA.includes(text) || DAKUON_HIRA.includes(text) || YOON_HIRA.includes(text)) color = '#FF8A80'; // å¹³å‡åç³»ç²‰è‰²
            else color = '#82B1FF'; // ç‰‡å‡åç³»è“è‰²
        }

        fruits.push({
            x: Math.random() * (width - 100) + 50,
            y: height + 50,
            vx: (Math.random() - 0.5) * 4, // æ°´å¹³é€Ÿåº¦
            vy: -(Math.random() * 5 + 10), // å‚ç›´åˆé€Ÿåº¦ (å‘ä¸Š)
            rot: 0,
            rotSpeed: (Math.random() - 0.5) * 0.2,
            type: type,
            text: text,
            color: color,
            radius: 40,
            active: true
        });
    }

    function checkSlice(x, y) {
        // ç®€å•çš„ç¢°æ’æ£€æµ‹ï¼šæ£€æŸ¥é¼ æ ‡ä½ç½®æ˜¯å¦åœ¨æ°´æœåŠå¾„å†…
        // æ›´å¥½çš„åšæ³•æ˜¯çº¿æ®µä¸åœ†çš„ç›¸äº¤ï¼Œè¿™é‡Œç®€åŒ–ä¸ºç‚¹ä¸åœ†ï¼Œå› ä¸ºé¼ æ ‡é¢‘ç‡é«˜
        fruits.forEach(f => {
            if (!f.active) return;
            const dx = x - f.x;
            const dy = y - f.y;
            if (dx*dx + dy*dy < f.radius * f.radius) {
                sliceFruit(f);
            }
        });
    }

    function sliceFruit(f) {
        f.active = false;
        createParticles(f.x, f.y, f.color);

        if (f.type === 'bomb') {
            gameOver();
        } else if (f.type === 'clock') {
            timeLeft += 10;
            showFloatText(f.x, f.y, "+10s", "#FFD700");
            playTone('bonus');
        } else {
            // æ£€æŸ¥æ˜¯å¦ç¬¦åˆå½“å‰ä»»åŠ¡
            if (currentTask.check(f.text)) {
                score += 10;
                showFloatText(f.x, f.y, "+10", "#4CAF50");
                playTone('hit');
            } else {
                score -= 10;
                showFloatText(f.x, f.y, "-10", "#F44336");
                playTone('wrong');
            }
        }
        document.getElementById('score-display').innerText = "å¾—åˆ†: " + score;
    }

    function createParticles(x, y, color) {
        for(let i=0; i<10; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: color
            });
        }
    }

    function update() {
        // ç”Ÿæˆé€»è¾‘ï¼šæ¯ç§’ 3-5 ä¸ª -> æ¯ 200-300ms ç”Ÿæˆä¸€ä¸ª
        spawnTimer++;
        if (spawnTimer > (Math.random() * 10 + 15)) { // çº¦ 15-25 å¸§ç”Ÿæˆä¸€ä¸ª
            spawnFruit();
            spawnTimer = 0;
        }

        // ä»»åŠ¡åˆ‡æ¢
        taskTimer++;
        if (taskTimer > 360) { // 60fps * 6s = 360
            changeTask();
            taskTimer = 0;
        }

        // æ›´æ–°æ°´æœ
        fruits.forEach(f => {
            f.x += f.vx;
            f.y += f.vy;
            f.vy += 0.2; // é‡åŠ›
            f.rot += f.rotSpeed;
        });
        // ç§»é™¤æ‰å‡ºå±å¹•çš„æ°´æœ
        fruits = fruits.filter(f => f.y < height + 100 && f.active);

        // æ›´æ–°ç²’å­
        particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
        });
        particles = particles.filter(p => p.life > 0);

        // æ›´æ–°è½¨è¿¹
        trail.forEach(t => t.life -= 0.1);
        trail = trail.filter(t => t.life > 0);
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);

        // ç”»æ°´æœ
        fruits.forEach(f => {
            ctx.save();
            ctx.translate(f.x, f.y);
            ctx.rotate(f.rot);
            
            // ç»˜åˆ¶åœ†å½¢èƒŒæ™¯
            ctx.beginPath();
            ctx.arc(0, 0, f.radius, 0, Math.PI*2);
            ctx.fillStyle = f.color;
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = "white";
            ctx.stroke();

            // ç»˜åˆ¶æ–‡å­—
            ctx.fillStyle = "white";
            ctx.font = "bold 30px Microsoft YaHei";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(f.text, 0, 0);
            
            ctx.restore();
        });

        // ç”»ç²’å­
        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        });

        // ç”»åˆ€å…‰è½¨è¿¹
        if (trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(trail[0].x, trail[0].y);
            for (let i = 1; i < trail.length; i++) {
                ctx.lineTo(trail[i].x, trail[i].y);
            }
            ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
            ctx.lineWidth = 5;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.stroke();
        }
    }

    function gameLoop() {
        if (gameState === 'playing') {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
    }

    function gameOver() {
        gameState = 'gameover';
        document.getElementById('menu-layer').style.display = 'flex';
        document.querySelector('#menu-layer h1').innerText = "æ¸¸æˆç»“æŸ";
        document.querySelector('#menu-layer p').innerHTML = `æœ€ç»ˆå¾—åˆ†: <span style="color:#FFD700; font-size:2rem">${score}</span>`;
        document.querySelector('.btn').innerText = "é‡æ–°æŒ‘æˆ˜";
    }

    function showFloatText(x, y, text, color) {
        // ç®€å•å¤„ç†ï¼šè¿™é‡Œå¯ä»¥ç”¨ DOM å…ƒç´ ï¼Œä¹Ÿå¯ä»¥ç”»åœ¨ Canvas ä¸Š
        // ä¸ºäº†æ€§èƒ½å’Œå±‚çº§ï¼Œè¿™é‡Œä¸ç”»äº†ï¼Œæˆ–è€…ä½ å¯ä»¥åŠ ä¸ªç®€å•çš„ Canvas ç»˜åˆ¶é€»è¾‘
    }

    // === éŸ³æ•ˆ ===
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playTone(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'hit') {
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'wrong') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.2);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(now); osc.stop(now + 0.2);
        } else if (type === 'bonus') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.setValueAtTime(1200, now + 0.1);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        }
    }

</script>
</body>
</html>
